{"version":3,"file":"exif.modern.js","sources":["../src/utils.ts","../src/extraction.ts","../src/index.ts","../src/extraction-datetime.ts"],"sourcesContent":["// TS type guard\nconst isFile = (e: File | string): e is File => typeof e !== \"string\";\n\n/**\n * A browser function for getting the width and height of an image.\n *\n * @param file {File}\n * @returns\n */\nconst getSizeInBrowser = async (\n  file: File,\n): Promise<{ width: number; height: number }> => {\n  return new Promise((resolve) => {\n    const URL = window.URL || window.webkitURL;\n    const image = new Image();\n\n    image.onload = () => {\n      resolve({\n        width: image.width,\n        height: image.height,\n      });\n    };\n\n    image.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Convert a time zone offset to minutes.  e.g., +02:00 => 120\n *\n * @param offset\n * @returns\n */\nconst offsetStringToMinutes = (offset: string): number => {\n  const split = offset.split(\":\");\n  const hours = parseInt(split[0]);\n  const minutes = parseInt(split[1]);\n\n  const factor = hours > 0 ? 1 : -1;\n\n  return hours * 60 + factor * minutes;\n};\n\nconst convertLatLonToDecimal = (\n  coord: string | null | undefined,\n): number | null => {\n  const match = coord?.match(/^(\\d+),(\\d+\\.\\d+)([NSWE])$/);\n\n  if (match) {\n    const [_, degreesStr, minutesStr, hemisphere] = match;\n    const degrees = parseInt(degreesStr, 10);\n    const minutes = parseFloat(minutesStr);\n\n    // Convert to decimal degrees\n    let decimal = degrees + minutes / 60;\n\n    // Apply hemisphere correction\n    if (hemisphere === \"S\" || hemisphere === \"W\") {\n      decimal *= -1;\n    }\n\n    return decimal;\n  } else {\n    return null;\n  }\n};\n\nconst roundToSignificantDigits = (\n  value: number | null | undefined,\n  n: number,\n): number | null => {\n  if (typeof value === \"number\") {\n    const multiplier = Math.pow(10, n);\n    return Math.round(value * multiplier) / multiplier;\n  } else {\n    return null;\n  }\n};\n\nexport {\n  isFile,\n  getSizeInBrowser,\n  offsetStringToMinutes,\n  convertLatLonToDecimal,\n  roundToSignificantDigits,\n};\n","import tzlookup from \"tz-lookup\";\nimport {\n  convertLatLonToDecimal,\n  getSizeInBrowser,\n  isFile,\n  roundToSignificantDigits,\n} from \"./utils\";\nimport { LocationInfo, RawExifData, SizeInfo, Source } from \"./types\";\nimport arrify from \"arrify\";\n\nconst extractTitle = (rawExif: RawExifData) => {\n  const title = rawExif.title?.value ?? rawExif.ObjectName ?? null;\n  return title ? String(title).trim() : null;\n};\n\nconst extractCaption = (rawExif: RawExifData) => {\n  const caption = rawExif.description?.value ?? rawExif.ImageDescription ??\n    rawExif.Caption ?? null;\n  return caption ? String(caption).trim() : null;\n};\n\nconst extractKeywords = (rawExif: RawExifData) => {\n  return arrify(\n    rawExif.Keywords ?? rawExif.subject ?? rawExif.weightedFlatSubject ?? [],\n  );\n};\n\nconst isValidNumber = (value: unknown): value is number =>\n  typeof value === \"number\" && Number.isFinite(value);\n\nconst isString = (value: unknown): value is string => typeof value === \"string\";\n\n/**\n * Extracts the latitude, longitude, and time zone. The latitude and longitude\n * are rounded to 6 significant digits.\n *\n * @param rawExif\n * @returns\n */\nconst extractLatLngTz = (rawExif: RawExifData): LocationInfo => {\n  // This can be NaN, number, or DMS\n\n  const rawLatitude = rawExif.latitude;\n  const rawLongitude = rawExif.longitude;\n\n  const rawGpsLatitude = rawExif.GPSLatitude;\n  const rawGpsLongitude = rawExif.GPSLongitude;\n\n  const latitude = isValidNumber(rawLatitude)\n    ? rawLatitude\n    : isString(rawGpsLatitude)\n    ? convertLatLonToDecimal(rawGpsLatitude)\n    : null;\n\n  const longitude = isValidNumber(rawLatitude)\n    ? rawLongitude\n    : isString(rawGpsLongitude)\n    ? convertLatLonToDecimal(rawGpsLongitude)\n    : null;\n\n  /*\n  const latitude = (rawExif.latitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLatitude) ??\n    null;\n\n  const longitude = (rawExif.longitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLongitude) ??\n    null;\n    */\n\n  // Use TZ service?\n  // https://trackmytour.com/tapi/tz/-3/55/\n  const timeZone = isValidNumber(latitude) && isValidNumber(longitude)\n    ? tzlookup(latitude, longitude)\n    : null;\n\n  // https://en.wikipedia.org/wiki/Decimal_degrees\n  return {\n    latitude: roundToSignificantDigits(latitude, 6),\n    longitude: roundToSignificantDigits(longitude, 6),\n    timeZone,\n  };\n};\n\n/**\n * Seems .jpg files exported from Lightroom does not contain width and height information.\n *\n * @param rawExif\n * @param item\n * @returns\n */\nconst extractHeightWidth = async (\n  rawExif: RawExifData,\n  item: Source,\n): Promise<SizeInfo> => {\n  let width = (rawExif.ImageWidth as number) ??\n    (rawExif.ExifImageWidth as number) ?? 0;\n  let height = (rawExif.ImageHeight as number) ??\n    (rawExif.ExifImageHeight as number) ?? 0;\n\n  if (width > 0 && height > 0) {\n    // great!\n  } else {\n    // if we have a file path, on node.js\n    if (typeof item === \"string\") {\n      // This block is for node.js only.\n      const { default: probe } = await import(\"probe-image-size\");\n      const fs = await import(\"fs\");\n      const results = await probe(fs.createReadStream(item));\n\n      if (results?.width && results?.height) {\n        width = results.width;\n        height = results.height;\n      }\n    } else if (window && isFile(item)) {\n      const results = await getSizeInBrowser(item);\n\n      width = results.width;\n      height = results.height;\n    } else {\n      // out of luck\n    }\n  }\n\n  return { width, height };\n};\n\nexport {\n  extractCaption,\n  extractHeightWidth,\n  extractKeywords,\n  extractLatLngTz,\n  extractTitle,\n};\n","import pkg from \"exifr\";\n\nimport {\n  extractCaption,\n  extractHeightWidth,\n  extractKeywords,\n  extractLatLngTz,\n  extractTitle,\n} from \"./extraction\";\n\nimport { type Source, type TExifData } from \"./types\";\nimport { extractDateTime } from \"./extraction-datetime\";\n\nconst { parse } = pkg;\n\nconst exif = async (item: Source): Promise<TExifData> => {\n  const _exif: TExifData = {\n    latitude: null,\n    longitude: null,\n    timeZone: null,\n    localTime: null,\n    timestamp: null,\n    title: null,\n    caption: null,\n    width: 0,\n    height: 0,\n\n    city: null,\n    state: null,\n    country: null,\n    countryCode: null,\n    rating: null,\n    mimetype: null,\n    keywords: [],\n  };\n\n  const data = await parse(item, true);\n\n  const locationInfo = extractLatLngTz(data);\n\n  _exif.latitude = locationInfo.latitude;\n  _exif.longitude = locationInfo.longitude;\n  _exif.timeZone = locationInfo.timeZone;\n  _exif.title = extractTitle(data);\n  _exif.caption = extractCaption(data);\n\n  _exif.city = data.City;\n  _exif.state = data.State;\n  _exif.country = data.Country;\n  _exif.countryCode = data.CountryCode;\n  _exif.rating = data.Rating;\n  _exif.mimetype = data.format;\n\n  _exif.keywords = extractKeywords(data);\n\n  const dateTimeInfo = extractDateTime(data, locationInfo);\n  _exif.localTime = dateTimeInfo.localTime;\n  _exif.timestamp = dateTimeInfo.timestamp;\n\n  const dimensionInfo = await extractHeightWidth(data, item);\n  _exif.width = dimensionInfo.width;\n  _exif.height = dimensionInfo.height;\n\n  return _exif;\n};\n\nexport { exif, type TExifData };\n","import { offsetStringToMinutes } from \"./utils\";\nimport { isDate, toDate, toDateInTimeZone, toDateUTC } from \"@chriscdn/to-date\";\nimport { formatDateYYYYMMDDTHHMMSS } from \"@chriscdn/format-date\";\nimport { DateTimeInfo, LocationInfo, RawExifData } from \"./types\";\n\nconst extractDateTime = (\n  rawExif: RawExifData,\n  locationInfo: LocationInfo,\n): DateTimeInfo => {\n  // The exifr lib returns a Date or string\n  const dateTimeOriginal: string | Date | null = rawExif.DateTimeOriginal ??\n    null;\n\n  const offsetTimeOriginal =\n    (rawExif.OffsetTimeOriginal as string | undefined) ?? null;\n\n  if (typeof dateTimeOriginal === \"string\") {\n    // PNGs seem to go this way\n    return _extractDateTimeFromString(dateTimeOriginal, locationInfo);\n  } else if (isDate(dateTimeOriginal)) {\n    // JPGs go this way\n    const offsetInMinutes = offsetTimeOriginal\n      ? offsetStringToMinutes(offsetTimeOriginal)\n      : null;\n\n    return _extractDateTimeFromDate(\n      dateTimeOriginal,\n      locationInfo,\n      offsetInMinutes,\n    );\n  } else {\n    // null case\n    return {\n      localTime: null,\n      timestamp: null,\n    };\n  }\n};\n\n/**\n * Exifr appears to return the DateTimeOriginal as a string with a time zone,\n * such as \"2024-12-21T18:59:43-05:00\", for PNG filesâ€”at least for those\n * exported from Lightroom.\n */\nconst _extractDateTimeFromString = (\n  dateTimeOriginal: string,\n  locationInfo: LocationInfo,\n) => {\n  // Dates with time zone (e.g., \"2024-12-21T18:59:43-05:00\") are parsed correctly.\n  const correctDate = toDate(dateTimeOriginal);\n\n  if (locationInfo.timeZone) {\n    return {\n      localTime: formatDateYYYYMMDDTHHMMSS(correctDate, locationInfo.timeZone),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  } else {\n    return {\n      // We want the *local time* for consistency, which we can get from dateTimeOriginal\n      localTime: dateTimeOriginal.slice(0, 19),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  }\n};\n\n/**\n * When exifr returns a date, it's incorrectly interpreted in the time zone of\n * the device. We correct it here.\n */\nconst _extractDateTimeFromDate = (\n  dateTimeOriginal: Date,\n  locationInfo: LocationInfo,\n  offsetInMinutes: number | null,\n): DateTimeInfo => {\n  // parsed in device tz, so we format it back in same tz\n  const localDateAsString = formatDateYYYYMMDDTHHMMSS(dateTimeOriginal);\n\n  // console.log(\n  //   `${localDateAsString} - ${offsetInMinutes} - ${locationInfo.timeZone}`,\n  // );\n\n  if (offsetInMinutes !== null) {\n    const utcDate = toDateUTC(localDateAsString);\n\n    if (utcDate) {\n      utcDate?.setMinutes(utcDate.getUTCMinutes() - offsetInMinutes);\n    }\n\n    return {\n      localTime: localDateAsString,\n      timestamp: utcDate?.getTime() ?? null,\n    };\n  } else if (locationInfo.timeZone) {\n    const fixedDate = toDateInTimeZone(\n      localDateAsString,\n      locationInfo.timeZone,\n    );\n\n    return {\n      localTime: localDateAsString,\n      timestamp: fixedDate?.getTime() ?? null,\n      // timeZoneOffsetInMinutes: null,\n    };\n  } else {\n    return {\n      localTime: localDateAsString,\n      timestamp: null,\n    };\n  }\n};\n\nexport { extractDateTime };\n"],"names":["convertLatLonToDecimal","coord","match","_","degreesStr","minutesStr","hemisphere","decimal","parseInt","parseFloat","roundToSignificantDigits","value","n","multiplier","Math","pow","round","isValidNumber","Number","isFinite","isString","parse","pkg","exif","async","_exif","latitude","longitude","timeZone","localTime","timestamp","title","caption","width","height","city","state","country","countryCode","rating","mimetype","keywords","data","item","locationInfo","rawExif","rawLatitude","rawLongitude","rawGpsLatitude","GPSLatitude","rawGpsLongitude","GPSLongitude","tzlookup","extractLatLngTz","_ref4","_ref5","_rawExif$Keywords","_ref","_rawExif$title$value","_rawExif$title","ObjectName","String","trim","extractTitle","_ref2","_ref3","_rawExif$description$","_rawExif$description","description","ImageDescription","Caption","extractCaption","City","State","Country","CountryCode","Rating","format","arrify","Keywords","subject","weightedFlatSubject","dateTimeInfo","extractDateTime","_rawExif$DateTimeOrig","_rawExif$OffsetTimeOr","dateTimeOriginal","DateTimeOriginal","offsetTimeOriginal","OffsetTimeOriginal","_extractDateTimeFromString","correctDate","toDate","_correctDate$getTime","_correctDate$getTime2","formatDateYYYYMMDDTHHMMSS","getTime","slice","isDate","_extractDateTimeFromDate","offsetInMinutes","localDateAsString","_utcDate$getTime","utcDate","toDateUTC","setMinutes","getUTCMinutes","_fixedDate$getTime","fixedDate","toDateInTimeZone","offset","split","hours","minutes","offsetStringToMinutes","dimensionInfo","_ref6","_rawExif$ImageWidth","_ref7","_rawExif$ImageHeight","ImageWidth","ExifImageWidth","ImageHeight","ExifImageHeight","default","probe","import","fs","results","createReadStream","window","Promise","resolve","URL","webkitURL","image","Image","onload","src","createObjectURL","file","getSizeInBrowser","extractHeightWidth"],"mappings":"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"}