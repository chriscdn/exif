{"version":3,"file":"exif.modern.js","sources":["../src/index.ts"],"sourcesContent":["import pkg from \"exifr\";\nconst { parse } = pkg;\n\nimport { DateTime } from \"luxon\";\nimport tzlookup from \"tz-lookup\";\n\nexport type TExifData = {\n  latitude: number | null;\n  longitude: number | null;\n  timeZone: string | null;\n  localTime: string | null; // e.g., 2023-01-01T09:45:64, relative to location\n  timestamp: number | null; // in milliseconds\n  timeZoneOffsetInMinutes: number | null;\n  description: string | null;\n  width: number;\n  height: number;\n  isPrecise: boolean;\n};\n\n// TS type guard\nfunction isFile(e: File | string): e is File {\n  return typeof e !== \"string\";\n}\n\nfunction isDate(value: unknown): value is Date {\n  return (\n    value instanceof Date ||\n    (typeof value === \"object\" &&\n      Object.prototype.toString.call(value) === \"[object Date]\")\n  );\n}\n\n/**\n * A browser function for getting the width and height of an image.\n *\n * @param file {File}\n * @returns\n */\nasync function getSizeInBrowser(\n  file: File\n): Promise<{ width: number; height: number }> {\n  return new Promise((resolve) => {\n    const URL = window.URL || window.webkitURL;\n    const image = new Image();\n\n    image.onload = () => {\n      resolve({\n        width: image.width,\n        height: image.height,\n      });\n    };\n\n    image.src = URL.createObjectURL(file);\n  });\n}\n\n//\n/**\n * Convert a time zone offset to minutes.  e.g., +02:00 => 120\n *\n * @param offset\n * @returns\n */\n\n// from luxon\n// Duration.fromISOTime('05:00').as('milliseconds'));\nfunction offsetStringToMinutes(offset: string): number {\n  const split = offset.split(\":\");\n  const hours = parseInt(split[0]);\n  const minutes = parseInt(split[1]);\n\n  const factor = hours > 0 ? 1 : -1;\n\n  return hours * 60 + factor * minutes;\n}\n\nconst exif = async (item: File | string): Promise<TExifData> => {\n  const _exif: TExifData = {\n    latitude: null,\n    longitude: null,\n    timeZone: null,\n    localTime: null,\n    timestamp: null,\n    timeZoneOffsetInMinutes: null,\n    description: null,\n    width: 0,\n    height: 0,\n    isPrecise: false,\n  };\n\n  const data = await parse(item, true);\n\n  _exif.latitude = data.latitude ?? null; //    get(data, \"latitude\", null);\n  _exif.longitude = data.longitude ?? null; // ; get(data, \"longitude\", null);\n\n  if (_exif.latitude && _exif.longitude) {\n    _exif.timeZone = tzlookup(_exif.latitude, _exif.longitude);\n  }\n\n  const imageDescription = data.ImageDescription ?? null;\n  _exif.description = imageDescription ? String(imageDescription).trim() : null;\n\n  // The exifr library gives us a Date object, but with the time zone of the\n  // computer doing the parsing.  This is really bad, so we must adjust this to\n  // get the correct time with the correct offset.\n  //\n  // https://github.com/MikeKovarik/exifr/issues/90\n\n  // Sometimes exifr gives us a string here (e.g., with PNG files).\n\n  const dateTimeOriginal: string | Date | null = data.DateTimeOriginal ?? null;\n\n  // This is the offset of the DateTimeOriginal.  This seems to be present in\n  // later versions of iOS, but older versions don't seem to have it.\n  //\n  // https://exiftool.org/TagNames/EXIF.html\n  const offsetTimeOriginal: string | null = data.OffsetTimeOriginal ?? null;\n\n  if (isDate(dateTimeOriginal)) {\n    // DateTimeOriginal is constructed by exifr and assumes local (browser, OS)\n    // time zone.  It's wrong.  We need to fix this.\n\n    const zone: string | null = _exif.timeZone;\n\n    const offsetInMinutes: number | null = offsetTimeOriginal\n      ? -offsetStringToMinutes(offsetTimeOriginal)\n      : null;\n\n    _exif.isPrecise = Boolean(zone) || Boolean(offsetInMinutes);\n\n    // DateTime is a luxon object.  The setZone function doesn't mutate the date\n    // and time, unless keepLocalTime is true.  What this means: Use the\n    // offsetInMinutes if we have it, otherwise, use the timeZone.  If neither\n    // are present then we are out of luck, and the system timeZone will be\n    // used.  An undefined zone implies the local time zone of the computer.\n\n    const fixedDateTime = DateTime.utc(\n      dateTimeOriginal.getFullYear(),\n      dateTimeOriginal.getMonth() + 1,\n      dateTimeOriginal.getDate(),\n      dateTimeOriginal.getHours(),\n      dateTimeOriginal.getMinutes(),\n      dateTimeOriginal.getSeconds()\n    )\n      .plus({ minutes: offsetInMinutes ?? undefined })\n      .setZone(zone ?? undefined, {\n        keepLocalTime: offsetInMinutes === undefined,\n      });\n\n    _exif.timestamp = fixedDateTime.toMillis();\n\n    // yes, negative, since we negated it earlier\n    _exif.timeZoneOffsetInMinutes = offsetInMinutes\n      ? -offsetInMinutes\n      : fixedDateTime.offset;\n\n    _exif.localTime = fixedDateTime.toFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n  }\n\n  _exif.width = data.ExifImageWidth ?? null;\n  _exif.height = data.ExifImageHeight ?? null;\n\n  if (!_exif.width && !_exif.height) {\n    // if we have a file path, on node.js\n    if (typeof item === \"string\") {\n      // This block is for node.js only.\n      const { default: probe } = await import(\"probe-image-size\");\n      const results = await probe(item);\n\n      if (results?.width && results?.height) {\n        _exif.width = results.width;\n        _exif.height = results.height;\n      }\n    } else if (window && isFile(item)) {\n      const results = await getSizeInBrowser(item);\n\n      _exif.width = results.width;\n      _exif.height = results.height;\n    } else {\n      // out of luck\n    }\n  }\n  return _exif;\n};\n\nexport default exif;\n"],"names":["parse","pkg","exif","async","_data$latitude","_data$longitude","_data$ImageDescriptio","_data$DateTimeOrigina","_data$OffsetTimeOrigi","_data$ExifImageWidth","_data$ExifImageHeight","_exif","latitude","longitude","timeZone","localTime","timestamp","timeZoneOffsetInMinutes","description","width","height","isPrecise","data","item","tzlookup","imageDescription","ImageDescription","String","trim","dateTimeOriginal","DateTimeOriginal","offsetTimeOriginal","OffsetTimeOriginal","value","Date","Object","prototype","toString","call","zone","offsetInMinutes","offset","split","hours","parseInt","offsetStringToMinutes","Boolean","fixedDateTime","DateTime","utc","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","plus","minutes","undefined","setZone","keepLocalTime","toMillis","toFormat","ExifImageWidth","ExifImageHeight","default","probe","import","results","window","file","Promise","resolve","URL","webkitURL","image","Image","onload","src","createObjectURL","getSizeInBrowser"],"mappings":"+EACA,MAAMA,MAAEA,GAAUC,EA2EZC,EAAOC,UAAkD,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAC7D,MAAMC,EAAmB,CACvBC,SAAU,KACVC,UAAW,KACXC,SAAU,KACVC,UAAW,KACXC,UAAW,KACXC,wBAAyB,KACzBC,YAAa,KACbC,MAAO,EACPC,OAAQ,EACRC,WAAW,GAGPC,QAAatB,EAAMuB,GAAM,GAE/BZ,EAAMC,SAAwB,OAAhBR,EAAGkB,EAAKV,UAAQR,EAAI,KAClCO,EAAME,UAA0B,OAAjBR,EAAGiB,EAAKT,WAASR,EAAI,KAEhCM,EAAMC,UAAYD,EAAME,YAC1BF,EAAMG,SAAWU,EAASb,EAAMC,SAAUD,EAAME,YAGlD,MAAMY,EAAwCnB,OAAxBA,EAAGgB,EAAKI,kBAAgBpB,EAAI,KAClDK,EAAMO,YAAcO,EAAmBE,OAAOF,GAAkBG,OAAS,KAUzE,MAAMC,EAA8D,OAA9CtB,EAAyBe,EAAKQ,kBAAgBvB,EAAI,KAMlEwB,EAA2D,OAAzCvB,EAAkBc,EAAKU,oBAAkBxB,EAAI,KAErE,IA9FcyB,EA8FHJ,aA5FQK,MACC,iBAAVD,GACoC,kBAA1CE,OAAOC,UAAUC,SAASC,KAAKL,GA0FL,CAI5B,MAAMM,EAAsB5B,EAAMG,SAE5B0B,EAAiCT,GA1D3C,SAA+BU,GAC7B,MAAMC,EAAQD,EAAOC,MAAM,KACrBC,EAAQC,SAASF,EAAM,IAK7B,OAAe,GAARC,GAFQA,EAAQ,EAAI,GAAK,GAFhBC,SAASF,EAAM,GAKjC,CAmDSG,CAAsBd,GACvB,KAEJpB,EAAMU,UAAYyB,QAAQP,IAASO,QAAQN,GAQ3C,MAAMO,EAAgBC,EAASC,IAC7BpB,EAAiBqB,cACjBrB,EAAiBsB,WAAa,EAC9BtB,EAAiBuB,UACjBvB,EAAiBwB,WACjBxB,EAAiByB,aACjBzB,EAAiB0B,cAEhBC,KAAK,CAAEC,QAAwB,MAAfjB,EAAAA,OAAmBkB,IACnCC,QAAQpB,MAAAA,EAAAA,OAAQmB,EAAW,CAC1BE,mBAAmCF,IAApBlB,IAGnB7B,EAAMK,UAAY+B,EAAcc,WAGhClD,EAAMM,wBAA0BuB,GAC3BA,EACDO,EAAcN,OAElB9B,EAAMI,UAAYgC,EAAce,SAAS,wBAC1C,CArIH,IAAgB7B,EA0Id,GAHAtB,EAAMQ,MAA2B,OAAtBV,EAAGa,EAAKyC,gBAActD,EAAI,KACrCE,EAAMS,OAA6B,OAAvBV,EAAGY,EAAK0C,iBAAetD,EAAI,MAElCC,EAAMQ,QAAUR,EAAMS,OAEzB,GAAoB,iBAATG,EAAmB,CAE5B,MAAQ0C,QAASC,SAAsBC,OAAC,oBAClCC,QAAgBF,EAAM3C,GAEjB,MAAP6C,GAAAA,EAASjD,aAASiD,GAAAA,EAAShD,SAC7BT,EAAMQ,MAAQiD,EAAQjD,MACtBR,EAAMS,OAASgD,EAAQhD,OAE1B,MAAM,GAAIiD,QAxJO,iBAwJU9C,EAAO,CACjC,MAAM6C,QAxIZjE,eACEmE,GAEA,OAAW,IAAAC,QAASC,IAClB,MAAMC,EAAMJ,OAAOI,KAAOJ,OAAOK,UAC3BC,EAAQ,IAAIC,MAElBD,EAAME,OAAS,KACbL,EAAQ,CACNrD,MAAOwD,EAAMxD,MACbC,OAAQuD,EAAMvD,QAElB,EAEAuD,EAAMG,IAAML,EAAIM,gBAAgBT,IAEpC,CAwH4BU,CAAiBzD,GAEvCZ,EAAMQ,MAAQiD,EAAQjD,MACtBR,EAAMS,OAASgD,EAAQhD,MACxB,CAIH,OAAOT"}