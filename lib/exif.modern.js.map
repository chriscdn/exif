{"version":3,"file":"exif.modern.js","sources":["../src/utils.ts","../src/index.ts","../src/extraction.ts","../src/extraction-datetime.ts"],"sourcesContent":["// TS type guard\nconst isFile = (e: File | string): e is File => typeof e !== \"string\";\n\n/**\n * A browser function for getting the width and height of an image.\n *\n * @param file {File}\n * @returns\n */\nconst getSizeInBrowser = async (\n  file: File,\n): Promise<{ width: number; height: number }> => {\n  return new Promise((resolve) => {\n    const URL = window.URL || window.webkitURL;\n    const image = new Image();\n\n    image.onload = () => {\n      resolve({\n        width: image.width,\n        height: image.height,\n      });\n    };\n\n    image.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Convert a time zone offset to minutes.  e.g., +02:00 => 120\n *\n * @param offset\n * @returns\n */\nconst offsetStringToMinutes = (offset: string): number => {\n  const split = offset.split(\":\");\n  const hours = parseInt(split[0]);\n  const minutes = parseInt(split[1]);\n\n  const factor = hours > 0 ? 1 : -1;\n\n  return hours * 60 + factor * minutes;\n};\n\nconst convertLatLonToDecimal = (\n  coord: string | null | undefined,\n): number | null => {\n  const match = coord?.match(/^(\\d+),(\\d+\\.\\d+)([NSWE])$/);\n\n  if (match) {\n    const [_, degreesStr, minutesStr, hemisphere] = match;\n    const degrees = parseInt(degreesStr, 10);\n    const minutes = parseFloat(minutesStr);\n\n    // Convert to decimal degrees\n    let decimal = degrees + minutes / 60;\n\n    // Apply hemisphere correction\n    if (hemisphere === \"S\" || hemisphere === \"W\") {\n      decimal *= -1;\n    }\n\n    return decimal;\n  } else {\n    return null;\n  }\n};\n\nconst roundToSignificantDigits = (\n  value: number | null | undefined,\n  n: number,\n): number | null => {\n  if (typeof value === \"number\") {\n    const multiplier = Math.pow(10, n);\n    return Math.round(value * multiplier) / multiplier;\n  } else {\n    return null;\n  }\n};\n\nexport {\n  isFile,\n  getSizeInBrowser,\n  offsetStringToMinutes,\n  convertLatLonToDecimal,\n  roundToSignificantDigits,\n};\n","import pkg from \"exifr\";\n\nimport {\n  extractDescription,\n  extractHeightWidth,\n  extractLatLngTz,\n} from \"./extraction\";\n\nimport { type Source, type TExifData } from \"./types\";\nimport { extractDateTime } from \"./extraction-datetime\";\n\nconst { parse } = pkg;\n\nconst exif = async (item: Source): Promise<TExifData> => {\n  const _exif: TExifData = {\n    latitude: null,\n    longitude: null,\n    timeZone: null,\n    localTime: null,\n    timestamp: null,\n    description: null,\n    width: 0,\n    height: 0,\n    // isPrecise: false,\n  };\n\n  const data = await parse(item, true);\n\n  // fs.promises.writeFile(\"./dump.json\", JSON.stringify(data), \"utf-8\");\n\n  const locationInfo = extractLatLngTz(data);\n\n  _exif.latitude = locationInfo.latitude;\n  _exif.longitude = locationInfo.longitude;\n  _exif.timeZone = locationInfo.timeZone;\n  _exif.description = extractDescription(data);\n\n  const dateTimeInfo = extractDateTime(data, locationInfo);\n  _exif.localTime = dateTimeInfo.localTime;\n  _exif.timestamp = dateTimeInfo.timestamp;\n\n  const dimensionInfo = await extractHeightWidth(data, item);\n  _exif.width = dimensionInfo.width;\n  _exif.height = dimensionInfo.height;\n\n  return _exif;\n};\n\nexport { exif, type TExifData };\n","import tzlookup from \"tz-lookup\";\nimport {\n  convertLatLonToDecimal,\n  getSizeInBrowser,\n  isFile,\n  roundToSignificantDigits,\n} from \"./utils\";\nimport { LocationInfo, RawExifData, SizeInfo, Source } from \"./types\";\n\nconst extractDescription = (rawExif: RawExifData) => {\n  const imageDescription = rawExif.ImageDescription ?? null;\n  return imageDescription ? String(imageDescription).trim() : null;\n};\n\n/**\n * Extracts the latitude, longitude, and time zone. The latitude and longitude\n * are rounded to 6 significant digits.\n *\n * @param rawExif\n * @returns\n */\nconst extractLatLngTz = (rawExif: RawExifData): LocationInfo => {\n  const latitude =\n    (rawExif.latitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLatitude) ??\n    null;\n\n  const longitude =\n    (rawExif.longitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLongitude) ??\n    null;\n\n  // Use TZ service?\n  // https://trackmytour.com/tapi/tz/-3/55/\n  const timeZone =\n    latitude !== null && longitude !== null\n      ? tzlookup(latitude, longitude)\n      : null;\n\n  // https://en.wikipedia.org/wiki/Decimal_degrees\n  return {\n    latitude: roundToSignificantDigits(latitude, 6),\n    longitude: roundToSignificantDigits(longitude, 6),\n    timeZone,\n  };\n};\n\n/**\n * Seems .jpg files exported from Lightroom does not contain width and height information.\n *\n * @param rawExif\n * @param item\n * @returns\n */\nconst extractHeightWidth = async (\n  rawExif: RawExifData,\n  item: Source,\n): Promise<SizeInfo> => {\n  let width =\n    (rawExif.ImageWidth as number) ?? (rawExif.ExifImageWidth as number) ?? 0;\n  let height =\n    (rawExif.ImageHeight as number) ?? (rawExif.ExifImageHeight as number) ?? 0;\n\n  if (width > 0 && height > 0) {\n    // great!\n  } else {\n    // if we have a file path, on node.js\n    if (typeof item === \"string\") {\n      // This block is for node.js only.\n      const { default: probe } = await import(\"probe-image-size\");\n      const fs = await import(\"fs\");\n      const results = await probe(fs.createReadStream(item));\n\n      if (results?.width && results?.height) {\n        width = results.width;\n        height = results.height;\n      }\n    } else if (window && isFile(item)) {\n      const results = await getSizeInBrowser(item);\n\n      width = results.width;\n      height = results.height;\n    } else {\n      // out of luck\n    }\n  }\n\n  return { width, height };\n};\n\nexport { extractDescription, extractLatLngTz, extractHeightWidth };\n","import { offsetStringToMinutes } from \"./utils\";\nimport { isDate, toDate, toDateInTimeZone, toDateUTC } from \"@chriscdn/to-date\";\nimport { formatDateYYYYMMDDTHHMMSS } from \"@chriscdn/format-date\";\nimport { DateTimeInfo, LocationInfo, RawExifData } from \"./types\";\n\nconst extractDateTime = (\n  rawExif: RawExifData,\n  locationInfo: LocationInfo,\n): DateTimeInfo => {\n  // The exifr lib returns a Date or string\n  const dateTimeOriginal: string | Date | null = rawExif.DateTimeOriginal ??\n    null;\n\n  const offsetTimeOriginal =\n    (rawExif.OffsetTimeOriginal as string | undefined) ?? null;\n\n  if (typeof dateTimeOriginal === \"string\") {\n    // PNGs seem to go this way\n    return _extractDateTimeFromString(dateTimeOriginal, locationInfo);\n  } else if (isDate(dateTimeOriginal)) {\n    // JPGs go this way\n    const offsetInMinutes = offsetTimeOriginal\n      ? offsetStringToMinutes(offsetTimeOriginal)\n      : null;\n\n    return _extractDateTimeFromDate(\n      dateTimeOriginal,\n      locationInfo,\n      offsetInMinutes,\n    );\n  } else {\n    // null case\n    return {\n      localTime: null,\n      timestamp: null,\n    };\n  }\n};\n\n/**\n * Exifr appears to return the DateTimeOriginal as a string with a time zone,\n * such as \"2024-12-21T18:59:43-05:00\", for PNG filesâ€”at least for those\n * exported from Lightroom.\n */\nconst _extractDateTimeFromString = (\n  dateTimeOriginal: string,\n  locationInfo: LocationInfo,\n) => {\n  // Dates with time zone (e.g., \"2024-12-21T18:59:43-05:00\") are parsed correctly.\n  const correctDate = toDate(dateTimeOriginal);\n\n  if (locationInfo.timeZone) {\n    return {\n      localTime: formatDateYYYYMMDDTHHMMSS(correctDate, locationInfo.timeZone),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  } else {\n    return {\n      // We want the *local time* for consistency, which we can get from dateTimeOriginal\n      localTime: dateTimeOriginal.slice(0, 19),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  }\n};\n\n/**\n * When exifr returns a date, it's incorrectly interpreted in the time zone of\n * the device. We correct it here.\n */\nconst _extractDateTimeFromDate = (\n  dateTimeOriginal: Date,\n  locationInfo: LocationInfo,\n  offsetInMinutes: number | null,\n): DateTimeInfo => {\n  // parsed in device tz, so we format it back in same tz\n  const localDateAsString = formatDateYYYYMMDDTHHMMSS(dateTimeOriginal);\n\n  // console.log(\n  //   `${localDateAsString} - ${offsetInMinutes} - ${locationInfo.timeZone}`,\n  // );\n\n  if (offsetInMinutes !== null) {\n    const utcDate = toDateUTC(localDateAsString);\n\n    if (utcDate) {\n      utcDate?.setMinutes(utcDate.getUTCMinutes() - offsetInMinutes);\n    }\n\n    return {\n      localTime: localDateAsString,\n      timestamp: utcDate?.getTime() ?? null,\n    };\n  } else if (locationInfo.timeZone) {\n    const fixedDate = toDateInTimeZone(\n      localDateAsString,\n      locationInfo.timeZone,\n    );\n\n    return {\n      localTime: localDateAsString,\n      timestamp: fixedDate?.getTime() ?? null,\n      // timeZoneOffsetInMinutes: null,\n    };\n  } else {\n    return {\n      localTime: localDateAsString,\n      timestamp: null,\n    };\n  }\n};\n\nexport { extractDateTime };\n"],"names":["convertLatLonToDecimal","coord","match","_","degreesStr","minutesStr","hemisphere","decimal","parseInt","parseFloat","roundToSignificantDigits","value","n","multiplier","Math","pow","round","parse","pkg","exif","async","_exif","latitude","longitude","timeZone","localTime","timestamp","description","width","height","data","item","locationInfo","rawExif","_ref","_rawExif$latitude","_ref2","_rawExif$longitude","GPSLatitude","GPSLongitude","tzlookup","extractLatLngTz","_rawExif$ImageDescrip","imageDescription","ImageDescription","String","trim","extractDescription","dateTimeInfo","extractDateTime","_rawExif$DateTimeOrig","_rawExif$OffsetTimeOr","dateTimeOriginal","DateTimeOriginal","offsetTimeOriginal","OffsetTimeOriginal","_extractDateTimeFromString","correctDate","toDate","_correctDate$getTime","_correctDate$getTime2","formatDateYYYYMMDDTHHMMSS","getTime","slice","isDate","_extractDateTimeFromDate","offsetInMinutes","localDateAsString","_utcDate$getTime","utcDate","toDateUTC","setMinutes","getUTCMinutes","_fixedDate$getTime","fixedDate","toDateInTimeZone","offset","split","hours","minutes","offsetStringToMinutes","dimensionInfo","_ref3","_rawExif$ImageWidth","_ref4","_rawExif$ImageHeight","ImageWidth","ExifImageWidth","ImageHeight","ExifImageHeight","default","probe","import","fs","results","createReadStream","window","Promise","resolve","URL","webkitURL","image","Image","onload","src","createObjectURL","file","getSizeInBrowser","extractHeightWidth"],"mappings":"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"}