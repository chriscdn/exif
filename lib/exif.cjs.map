{"version":3,"file":"exif.cjs","sources":["../src/utils.ts","../src/extraction.ts","../src/index.ts","../src/extraction-datetime.ts"],"sourcesContent":["// TS type guard\nconst isFile = (e: File | string): e is File => typeof e !== \"string\";\n\n/**\n * A browser function for getting the width and height of an image.\n *\n * @param file {File}\n * @returns\n */\nconst getSizeInBrowser = async (\n  file: File,\n): Promise<{ width: number; height: number }> => {\n  return new Promise((resolve) => {\n    const URL = window.URL || window.webkitURL;\n    const image = new Image();\n\n    image.onload = () => {\n      resolve({\n        width: image.width,\n        height: image.height,\n      });\n    };\n\n    image.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Convert a time zone offset to minutes.  e.g., +02:00 => 120\n *\n * @param offset\n * @returns\n */\nconst offsetStringToMinutes = (offset: string): number => {\n  const split = offset.split(\":\");\n  const hours = parseInt(split[0]);\n  const minutes = parseInt(split[1]);\n\n  const factor = hours > 0 ? 1 : -1;\n\n  return hours * 60 + factor * minutes;\n};\n\nconst convertLatLonToDecimal = (\n  coord: string | null | undefined,\n): number | null => {\n  const match = coord?.match(/^(\\d+),(\\d+\\.\\d+)([NSWE])$/);\n\n  if (match) {\n    const [_, degreesStr, minutesStr, hemisphere] = match;\n    const degrees = parseInt(degreesStr, 10);\n    const minutes = parseFloat(minutesStr);\n\n    // Convert to decimal degrees\n    let decimal = degrees + minutes / 60;\n\n    // Apply hemisphere correction\n    if (hemisphere === \"S\" || hemisphere === \"W\") {\n      decimal *= -1;\n    }\n\n    return decimal;\n  } else {\n    return null;\n  }\n};\n\nconst roundToSignificantDigits = (\n  value: number | null | undefined,\n  n: number,\n): number | null => {\n  if (typeof value === \"number\") {\n    const multiplier = Math.pow(10, n);\n    return Math.round(value * multiplier) / multiplier;\n  } else {\n    return null;\n  }\n};\n\nexport {\n  isFile,\n  getSizeInBrowser,\n  offsetStringToMinutes,\n  convertLatLonToDecimal,\n  roundToSignificantDigits,\n};\n","import tzlookup from \"tz-lookup\";\nimport {\n  convertLatLonToDecimal,\n  getSizeInBrowser,\n  isFile,\n  roundToSignificantDigits,\n} from \"./utils\";\nimport { LocationInfo, RawExifData, SizeInfo, Source } from \"./types\";\nimport arrify from \"arrify\";\n\nconst extractTitle = (rawExif: RawExifData) => {\n  const title = rawExif.title?.value ?? rawExif.ObjectName ?? null;\n  return title ? String(title).trim() : null;\n};\n\nconst extractCaption = (rawExif: RawExifData) => {\n  const caption = rawExif.description?.value ?? rawExif.ImageDescription ??\n    rawExif.Caption ?? null;\n  return caption ? String(caption).trim() : null;\n};\n\nconst extractKeywords = (rawExif: RawExifData) => {\n  return arrify(\n    rawExif.Keywords ?? rawExif.subject ?? rawExif.weightedFlatSubject ?? [],\n  );\n};\n\nconst isValidNumber = (value: unknown): value is number =>\n  typeof value === \"number\" && Number.isFinite(value);\n\n/**\n * Extracts the latitude, longitude, and time zone. The latitude and longitude\n * are rounded to 6 significant digits.\n *\n * @param rawExif\n * @returns\n */\nconst extractLatLngTz = (rawExif: RawExifData): LocationInfo => {\n  const latitude = (rawExif.latitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLatitude) ??\n    null;\n\n  const longitude = (rawExif.longitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLongitude) ??\n    null;\n\n  // Use TZ service?\n  // https://trackmytour.com/tapi/tz/-3/55/\n  const timeZone = isValidNumber(latitude) && isValidNumber(longitude)\n    ? tzlookup(latitude, longitude)\n    : null;\n\n  // https://en.wikipedia.org/wiki/Decimal_degrees\n  return {\n    latitude: roundToSignificantDigits(latitude, 6),\n    longitude: roundToSignificantDigits(longitude, 6),\n    timeZone,\n  };\n};\n\n/**\n * Seems .jpg files exported from Lightroom does not contain width and height information.\n *\n * @param rawExif\n * @param item\n * @returns\n */\nconst extractHeightWidth = async (\n  rawExif: RawExifData,\n  item: Source,\n): Promise<SizeInfo> => {\n  let width = (rawExif.ImageWidth as number) ??\n    (rawExif.ExifImageWidth as number) ?? 0;\n  let height = (rawExif.ImageHeight as number) ??\n    (rawExif.ExifImageHeight as number) ?? 0;\n\n  if (width > 0 && height > 0) {\n    // great!\n  } else {\n    // if we have a file path, on node.js\n    if (typeof item === \"string\") {\n      // This block is for node.js only.\n      const { default: probe } = await import(\"probe-image-size\");\n      const fs = await import(\"fs\");\n      const results = await probe(fs.createReadStream(item));\n\n      if (results?.width && results?.height) {\n        width = results.width;\n        height = results.height;\n      }\n    } else if (window && isFile(item)) {\n      const results = await getSizeInBrowser(item);\n\n      width = results.width;\n      height = results.height;\n    } else {\n      // out of luck\n    }\n  }\n\n  return { width, height };\n};\n\nexport {\n  extractCaption,\n  extractHeightWidth,\n  extractKeywords,\n  extractLatLngTz,\n  extractTitle,\n};\n","import pkg from \"exifr\";\n\nimport {\n  extractCaption,\n  extractHeightWidth,\n  extractKeywords,\n  extractLatLngTz,\n  extractTitle,\n} from \"./extraction\";\n\nimport { type Source, type TExifData } from \"./types\";\nimport { extractDateTime } from \"./extraction-datetime\";\n\nconst { parse } = pkg;\n\nconst exif = async (item: Source): Promise<TExifData> => {\n  const _exif: TExifData = {\n    latitude: null,\n    longitude: null,\n    timeZone: null,\n    localTime: null,\n    timestamp: null,\n    title: null,\n    caption: null,\n    width: 0,\n    height: 0,\n\n    city: null,\n    state: null,\n    country: null,\n    countryCode: null,\n    rating: null,\n    mimetype: null,\n    keywords: [],\n  };\n\n  const data = await parse(item, true);\n\n  const locationInfo = extractLatLngTz(data);\n\n  _exif.latitude = locationInfo.latitude;\n  _exif.longitude = locationInfo.longitude;\n  _exif.timeZone = locationInfo.timeZone;\n  _exif.title = extractTitle(data);\n  _exif.caption = extractCaption(data);\n\n  _exif.city = data.City;\n  _exif.state = data.State;\n  _exif.country = data.Country;\n  _exif.countryCode = data.CountryCode;\n  _exif.rating = data.Rating;\n  _exif.mimetype = data.format;\n\n  _exif.keywords = extractKeywords(data);\n\n  const dateTimeInfo = extractDateTime(data, locationInfo);\n  _exif.localTime = dateTimeInfo.localTime;\n  _exif.timestamp = dateTimeInfo.timestamp;\n\n  const dimensionInfo = await extractHeightWidth(data, item);\n  _exif.width = dimensionInfo.width;\n  _exif.height = dimensionInfo.height;\n\n  return _exif;\n};\n\nexport { exif, type TExifData };\n","import { offsetStringToMinutes } from \"./utils\";\nimport { isDate, toDate, toDateInTimeZone, toDateUTC } from \"@chriscdn/to-date\";\nimport { formatDateYYYYMMDDTHHMMSS } from \"@chriscdn/format-date\";\nimport { DateTimeInfo, LocationInfo, RawExifData } from \"./types\";\n\nconst extractDateTime = (\n  rawExif: RawExifData,\n  locationInfo: LocationInfo,\n): DateTimeInfo => {\n  // The exifr lib returns a Date or string\n  const dateTimeOriginal: string | Date | null = rawExif.DateTimeOriginal ??\n    null;\n\n  const offsetTimeOriginal =\n    (rawExif.OffsetTimeOriginal as string | undefined) ?? null;\n\n  if (typeof dateTimeOriginal === \"string\") {\n    // PNGs seem to go this way\n    return _extractDateTimeFromString(dateTimeOriginal, locationInfo);\n  } else if (isDate(dateTimeOriginal)) {\n    // JPGs go this way\n    const offsetInMinutes = offsetTimeOriginal\n      ? offsetStringToMinutes(offsetTimeOriginal)\n      : null;\n\n    return _extractDateTimeFromDate(\n      dateTimeOriginal,\n      locationInfo,\n      offsetInMinutes,\n    );\n  } else {\n    // null case\n    return {\n      localTime: null,\n      timestamp: null,\n    };\n  }\n};\n\n/**\n * Exifr appears to return the DateTimeOriginal as a string with a time zone,\n * such as \"2024-12-21T18:59:43-05:00\", for PNG filesâ€”at least for those\n * exported from Lightroom.\n */\nconst _extractDateTimeFromString = (\n  dateTimeOriginal: string,\n  locationInfo: LocationInfo,\n) => {\n  // Dates with time zone (e.g., \"2024-12-21T18:59:43-05:00\") are parsed correctly.\n  const correctDate = toDate(dateTimeOriginal);\n\n  if (locationInfo.timeZone) {\n    return {\n      localTime: formatDateYYYYMMDDTHHMMSS(correctDate, locationInfo.timeZone),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  } else {\n    return {\n      // We want the *local time* for consistency, which we can get from dateTimeOriginal\n      localTime: dateTimeOriginal.slice(0, 19),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  }\n};\n\n/**\n * When exifr returns a date, it's incorrectly interpreted in the time zone of\n * the device. We correct it here.\n */\nconst _extractDateTimeFromDate = (\n  dateTimeOriginal: Date,\n  locationInfo: LocationInfo,\n  offsetInMinutes: number | null,\n): DateTimeInfo => {\n  // parsed in device tz, so we format it back in same tz\n  const localDateAsString = formatDateYYYYMMDDTHHMMSS(dateTimeOriginal);\n\n  // console.log(\n  //   `${localDateAsString} - ${offsetInMinutes} - ${locationInfo.timeZone}`,\n  // );\n\n  if (offsetInMinutes !== null) {\n    const utcDate = toDateUTC(localDateAsString);\n\n    if (utcDate) {\n      utcDate?.setMinutes(utcDate.getUTCMinutes() - offsetInMinutes);\n    }\n\n    return {\n      localTime: localDateAsString,\n      timestamp: utcDate?.getTime() ?? null,\n    };\n  } else if (locationInfo.timeZone) {\n    const fixedDate = toDateInTimeZone(\n      localDateAsString,\n      locationInfo.timeZone,\n    );\n\n    return {\n      localTime: localDateAsString,\n      timestamp: fixedDate?.getTime() ?? null,\n      // timeZoneOffsetInMinutes: null,\n    };\n  } else {\n    return {\n      localTime: localDateAsString,\n      timestamp: null,\n    };\n  }\n};\n\nexport { extractDateTime };\n"],"names":["convertLatLonToDecimal","coord","match","minutesStr","hemisphere","decimal","parseInt","parseFloat","roundToSignificantDigits","value","n","multiplier","Math","pow","round","isValidNumber","Number","isFinite","parse","pkg","item","_exif","latitude","longitude","timeZone","localTime","timestamp","title","caption","width","height","city","state","country","countryCode","rating","mimetype","keywords","Promise","resolve","then","data","rawExif","_ref6","_rawExif$latitude","_ref7","_rawExif$longitude","locationInfo","GPSLatitude","GPSLongitude","tzlookup","_ref","_rawExif$title$value","_rawExif$title","ObjectName","String","trim","extractTitle","_ref2","_ref3","_rawExif$description$","_rawExif$description","description","ImageDescription","Caption","extractCaption","City","State","Country","CountryCode","Rating","format","_ref4","_ref5","_rawExif$Keywords","arrify","Keywords","subject","weightedFlatSubject","extractKeywords","dateTimeInfo","_rawExif$DateTimeOrig","_rawExif$OffsetTimeOr","split","hours","dateTimeOriginal","DateTimeOriginal","offsetTimeOriginal","OffsetTimeOriginal","_correctDate$getTime","_correctDate$getTime2","correctDate","toDate","formatDateYYYYMMDDTHHMMSS","getTime","slice","_extractDateTimeFromString","isDate","offsetInMinutes","localDateAsString","_utcDate$getTime","utcDate","toDateUTC","setMinutes","getUTCMinutes","_fixedDate$getTime","fixedDate","toDateInTimeZone","_extractDateTimeFromDate","extractDateTime","_ref8","_rawExif$ImageWidth","_ref9","_rawExif$ImageHeight","_temp4","ImageWidth","ExifImageWidth","ImageHeight","ExifImageHeight","_temp3","_temp2","_interopNamespace","require","_ref10","probe","fs","createReadStream","results","_temp5","window","file","URL","webkitURL","image","Image","onload","src","createObjectURL","e","reject","getSizeInBrowser","extractHeightWidth","dimensionInfo"],"mappings":"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"}