{"version":3,"file":"exif.module.js","sources":["../src/index.ts"],"sourcesContent":["import pkg from \"exifr\";\nconst { parse } = pkg;\n\nimport { DateTime } from \"luxon\";\nimport tzlookup from \"tz-lookup\";\n\nexport type TExifData = {\n  latitude: number | null;\n  longitude: number | null;\n  timeZone: string | null;\n  localTime: string | null; // e.g., 2023-01-01T09:45:64, relative to location\n  timestamp: number | null; // in milliseconds\n  timeZoneOffsetInMinutes: number | null;\n  description: string | null;\n  width: number;\n  height: number;\n  isPrecise: boolean;\n};\n\n// TS type guard\nfunction isFile(e: File | string): e is File {\n  return typeof e !== \"string\";\n}\n\nfunction isDate(value: unknown): value is Date {\n  return (\n    value instanceof Date ||\n    (typeof value === \"object\" &&\n      Object.prototype.toString.call(value) === \"[object Date]\")\n  );\n}\n\n/**\n * A browser function for getting the width and height of an image.\n *\n * @param file {File}\n * @returns\n */\nasync function getSizeInBrowser(\n  file: File\n): Promise<{ width: number; height: number }> {\n  return new Promise((resolve) => {\n    const URL = window.URL || window.webkitURL;\n    const image = new Image();\n\n    image.onload = () => {\n      resolve({\n        width: image.width,\n        height: image.height,\n      });\n    };\n\n    image.src = URL.createObjectURL(file);\n  });\n}\n\n//\n/**\n * Convert a time zone offset to minutes.  e.g., +02:00 => 120\n *\n * @param offset\n * @returns\n */\n\n// from luxon\n// Duration.fromISOTime('05:00').as('milliseconds'));\nfunction offsetStringToMinutes(offset: string): number {\n  const split = offset.split(\":\");\n  const hours = parseInt(split[0]);\n  const minutes = parseInt(split[1]);\n\n  const factor = hours > 0 ? 1 : -1;\n\n  return hours * 60 + factor * minutes;\n}\n\nconst exif = async (item: File | string): Promise<TExifData> => {\n  const _exif: TExifData = {\n    latitude: null,\n    longitude: null,\n    timeZone: null,\n    localTime: null,\n    timestamp: null,\n    timeZoneOffsetInMinutes: null,\n    description: null,\n    width: 0,\n    height: 0,\n    isPrecise: false,\n  };\n\n  const data = await parse(item, true);\n\n  _exif.latitude = data.latitude ?? null; //    get(data, \"latitude\", null);\n  _exif.longitude = data.longitude ?? null; // ; get(data, \"longitude\", null);\n\n  if (_exif.latitude && _exif.longitude) {\n    _exif.timeZone = tzlookup(_exif.latitude, _exif.longitude);\n  }\n\n  const imageDescription = data.ImageDescription ?? null;\n  _exif.description = imageDescription ? String(imageDescription).trim() : null;\n\n  // The exifr library gives us a Date object, but with the time zone of the\n  // computer doing the parsing.  This is really bad, so we must adjust this to\n  // get the correct time with the correct offset.\n  //\n  // https://github.com/MikeKovarik/exifr/issues/90\n\n  // Sometimes exifr gives us a string here (e.g., with PNG files).\n\n  const dateTimeOriginal: string | Date | null = data.DateTimeOriginal ?? null;\n\n  // This is the offset of the DateTimeOriginal.  This seems to be present in\n  // later versions of iOS, but older versions don't seem to have it.\n  //\n  // https://exiftool.org/TagNames/EXIF.html\n  const offsetTimeOriginal: string | null = data.OffsetTimeOriginal ?? null;\n\n  if (isDate(dateTimeOriginal)) {\n    // DateTimeOriginal is constructed by exifr and assumes local (browser, OS)\n    // time zone.  It's wrong.  We need to fix this.\n\n    const zone: string | null = _exif.timeZone;\n\n    const offsetInMinutes: number | null = offsetTimeOriginal\n      ? -offsetStringToMinutes(offsetTimeOriginal)\n      : null;\n\n    _exif.isPrecise = Boolean(zone) || Boolean(offsetInMinutes);\n\n    // DateTime is a luxon object.  The setZone function doesn't mutate the date\n    // and time, unless keepLocalTime is true.  What this means: Use the\n    // offsetInMinutes if we have it, otherwise, use the timeZone.  If neither\n    // are present then we are out of luck, and the system timeZone will be\n    // used.  An undefined zone implies the local time zone of the computer.\n\n    const fixedDateTime = DateTime.utc(\n      dateTimeOriginal.getFullYear(),\n      dateTimeOriginal.getMonth() + 1,\n      dateTimeOriginal.getDate(),\n      dateTimeOriginal.getHours(),\n      dateTimeOriginal.getMinutes(),\n      dateTimeOriginal.getSeconds()\n    )\n      .plus({ minutes: offsetInMinutes ?? undefined })\n      .setZone(zone ?? undefined, {\n        keepLocalTime: offsetInMinutes === undefined,\n      });\n\n    _exif.timestamp = fixedDateTime.toMillis();\n\n    // yes, negative, since we negated it earlier\n    _exif.timeZoneOffsetInMinutes = offsetInMinutes\n      ? -offsetInMinutes\n      : fixedDateTime.offset;\n\n    _exif.localTime = fixedDateTime.toFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n  }\n\n  _exif.width = data.ExifImageWidth ?? null;\n  _exif.height = data.ExifImageHeight ?? null;\n\n  if (!_exif.width && !_exif.height) {\n    // if we have a file path, on node.js\n    if (typeof item === \"string\") {\n      // This block is for node.js only.\n      const { default: probe } = await import(\"probe-image-size\");\n      const results = await probe(item);\n\n      if (results?.width && results?.height) {\n        _exif.width = results.width;\n        _exif.height = results.height;\n      }\n    } else if (window && isFile(item)) {\n      const results = await getSizeInBrowser(item);\n\n      _exif.width = results.width;\n      _exif.height = results.height;\n    } else {\n      // out of luck\n    }\n  }\n  return _exif;\n};\n\nexport default exif;\n"],"names":["parse","pkg","exif","item","_exif","latitude","longitude","timeZone","localTime","timestamp","timeZoneOffsetInMinutes","description","width","height","isPrecise","Promise","resolve","then","data","_data$latitude","_data$longitude","_data$ImageDescriptio","_data$DateTimeOrigina","_data$OffsetTimeOrigi","_data$ExifImageWidth","_data$ExifImageHeight","tzlookup","imageDescription","ImageDescription","String","trim","split","hours","value","dateTimeOriginal","DateTimeOriginal","offsetTimeOriginal","OffsetTimeOriginal","Date","Object","prototype","toString","call","zone","offsetInMinutes","parseInt","Boolean","fixedDateTime","DateTime","utc","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","plus","minutes","undefined","setZone","keepLocalTime","toMillis","offset","toFormat","ExifImageWidth","ExifImageHeight","_temp3","_temp2","import","_ref","probe","results","_temp4","window","file","URL","webkitURL","image","Image","onload","src","createObjectURL","e","reject","getSizeInBrowser"],"mappings":"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"}