{"version":3,"file":"exif.module.js","sources":["../src/utils.ts","../src/index.ts","../src/extraction.ts","../src/extraction-datetime.ts"],"sourcesContent":["// TS type guard\nconst isFile = (e: File | string): e is File => typeof e !== \"string\";\n\n/**\n * A browser function for getting the width and height of an image.\n *\n * @param file {File}\n * @returns\n */\nconst getSizeInBrowser = async (\n  file: File,\n): Promise<{ width: number; height: number }> => {\n  return new Promise((resolve) => {\n    const URL = window.URL || window.webkitURL;\n    const image = new Image();\n\n    image.onload = () => {\n      resolve({\n        width: image.width,\n        height: image.height,\n      });\n    };\n\n    image.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Convert a time zone offset to minutes.  e.g., +02:00 => 120\n *\n * @param offset\n * @returns\n */\nconst offsetStringToMinutes = (offset: string): number => {\n  const split = offset.split(\":\");\n  const hours = parseInt(split[0]);\n  const minutes = parseInt(split[1]);\n\n  const factor = hours > 0 ? 1 : -1;\n\n  return hours * 60 + factor * minutes;\n};\n\nconst convertLatLonToDecimal = (\n  coord: string | null | undefined,\n): number | null => {\n  const match = coord?.match(/^(\\d+),(\\d+\\.\\d+)([NSWE])$/);\n\n  if (match) {\n    const [_, degreesStr, minutesStr, hemisphere] = match;\n    const degrees = parseInt(degreesStr, 10);\n    const minutes = parseFloat(minutesStr);\n\n    // Convert to decimal degrees\n    let decimal = degrees + minutes / 60;\n\n    // Apply hemisphere correction\n    if (hemisphere === \"S\" || hemisphere === \"W\") {\n      decimal *= -1;\n    }\n\n    return decimal;\n  } else {\n    return null;\n  }\n};\n\nconst roundToSignificantDigits = (\n  value: number | null | undefined,\n  n: number,\n): number | null => {\n  if (typeof value === \"number\") {\n    const multiplier = Math.pow(10, n);\n    return Math.round(value * multiplier) / multiplier;\n  } else {\n    return null;\n  }\n};\n\nexport {\n  isFile,\n  getSizeInBrowser,\n  offsetStringToMinutes,\n  convertLatLonToDecimal,\n  roundToSignificantDigits,\n};\n","import pkg from \"exifr\";\n\nimport {\n  extractDescription,\n  extractHeightWidth,\n  extractLatLngTz,\n} from \"./extraction\";\n\nimport { type Source, type TExifData } from \"./types\";\nimport { extractDateTime } from \"./extraction-datetime\";\n\nconst { parse } = pkg;\n\nconst exif = async (item: Source): Promise<TExifData> => {\n  const _exif: TExifData = {\n    latitude: null,\n    longitude: null,\n    timeZone: null,\n    localTime: null,\n    timestamp: null,\n    description: null,\n    width: 0,\n    height: 0,\n    // isPrecise: false,\n  };\n\n  const data = await parse(item, true);\n\n  // fs.promises.writeFile(\"./dump.json\", JSON.stringify(data), \"utf-8\");\n\n  const locationInfo = extractLatLngTz(data);\n\n  _exif.latitude = locationInfo.latitude;\n  _exif.longitude = locationInfo.longitude;\n  _exif.timeZone = locationInfo.timeZone;\n  _exif.description = extractDescription(data);\n\n  const dateTimeInfo = extractDateTime(data, locationInfo);\n  _exif.localTime = dateTimeInfo.localTime;\n  _exif.timestamp = dateTimeInfo.timestamp;\n\n  const dimensionInfo = await extractHeightWidth(data, item);\n  _exif.width = dimensionInfo.width;\n  _exif.height = dimensionInfo.height;\n\n  return _exif;\n};\n\nexport { exif, type TExifData };\n","import tzlookup from \"tz-lookup\";\nimport {\n  convertLatLonToDecimal,\n  getSizeInBrowser,\n  isFile,\n  roundToSignificantDigits,\n} from \"./utils\";\nimport { LocationInfo, RawExifData, SizeInfo, Source } from \"./types\";\n\nconst extractDescription = (rawExif: RawExifData) => {\n  const imageDescription = rawExif.ImageDescription ?? null;\n  return imageDescription ? String(imageDescription).trim() : null;\n};\n\n/**\n * Extracts the latitude, longitude, and time zone. The latitude and longitude\n * are rounded to 6 significant digits.\n *\n * @param rawExif\n * @returns\n */\nconst extractLatLngTz = (rawExif: RawExifData): LocationInfo => {\n  const latitude =\n    (rawExif.latitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLatitude) ??\n    null;\n\n  const longitude =\n    (rawExif.longitude as number) ??\n    convertLatLonToDecimal(rawExif.GPSLongitude) ??\n    null;\n\n  // Use TZ service?\n  // https://trackmytour.com/tapi/tz/-3/55/\n  const timeZone =\n    latitude !== null && longitude !== null\n      ? tzlookup(latitude, longitude)\n      : null;\n\n  // https://en.wikipedia.org/wiki/Decimal_degrees\n  return {\n    latitude: roundToSignificantDigits(latitude, 6),\n    longitude: roundToSignificantDigits(longitude, 6),\n    timeZone,\n  };\n};\n\n/**\n * Seems .jpg files exported from Lightroom does not contain width and height information.\n *\n * @param rawExif\n * @param item\n * @returns\n */\nconst extractHeightWidth = async (\n  rawExif: RawExifData,\n  item: Source,\n): Promise<SizeInfo> => {\n  let width =\n    (rawExif.ImageWidth as number) ?? (rawExif.ExifImageWidth as number) ?? 0;\n  let height =\n    (rawExif.ImageHeight as number) ?? (rawExif.ExifImageHeight as number) ?? 0;\n\n  if (width > 0 && height > 0) {\n    // great!\n  } else {\n    // if we have a file path, on node.js\n    if (typeof item === \"string\") {\n      // This block is for node.js only.\n      const { default: probe } = await import(\"probe-image-size\");\n      const fs = await import(\"fs\");\n      const results = await probe(fs.createReadStream(item));\n\n      if (results?.width && results?.height) {\n        width = results.width;\n        height = results.height;\n      }\n    } else if (window && isFile(item)) {\n      const results = await getSizeInBrowser(item);\n\n      width = results.width;\n      height = results.height;\n    } else {\n      // out of luck\n    }\n  }\n\n  return { width, height };\n};\n\nexport { extractDescription, extractLatLngTz, extractHeightWidth };\n","import { offsetStringToMinutes } from \"./utils\";\nimport { isDate, toDate, toDateInTimeZone, toDateUTC } from \"@chriscdn/to-date\";\nimport { formatDateYYYYMMDDTHHMMSS } from \"@chriscdn/format-date\";\nimport { DateTimeInfo, LocationInfo, RawExifData } from \"./types\";\n\nconst extractDateTime = (\n  rawExif: RawExifData,\n  locationInfo: LocationInfo,\n): DateTimeInfo => {\n  // The exifr lib returns a Date or string\n  const dateTimeOriginal: string | Date | null =\n    rawExif.DateTimeOriginal ?? null;\n\n  const offsetTimeOriginal =\n    (rawExif.OffsetTimeOriginal as string | undefined) ?? null;\n\n  if (typeof dateTimeOriginal === \"string\") {\n    // PNGs seem to go this way\n    return _extractDateTimeFromString(dateTimeOriginal, locationInfo);\n  } else if (isDate(dateTimeOriginal)) {\n    // JPGs go this way\n    const offsetInMinutes = offsetTimeOriginal\n      ? offsetStringToMinutes(offsetTimeOriginal)\n      : null;\n\n    return _extractDateTimeFromDate(\n      dateTimeOriginal,\n      locationInfo,\n      offsetInMinutes,\n    );\n  } else {\n    // null case\n    return {\n      localTime: null,\n      timestamp: null,\n    };\n  }\n};\n\n/**\n * Exifr appears to return the DateTimeOriginal as a string with a time zone,\n * such as \"2024-12-21T18:59:43-05:00\", for PNG filesâ€”at least for those\n * exported from Lightroom.\n */\nconst _extractDateTimeFromString = (\n  dateTimeOriginal: string,\n  locationInfo: LocationInfo,\n) => {\n  // Dates with time zone (e.g., \"2024-12-21T18:59:43-05:00\") are parsed correctly.\n  const correctDate = toDate(dateTimeOriginal);\n\n  if (locationInfo.timeZone) {\n    return {\n      localTime: formatDateYYYYMMDDTHHMMSS(correctDate, locationInfo.timeZone),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  } else {\n    return {\n      // We want the *local time* for consistency, which we can get from dateTimeOriginal\n      localTime: dateTimeOriginal.slice(0, 19),\n      timestamp: correctDate?.getTime() ?? null,\n    };\n  }\n};\n\n/**\n * When exifr returns a date, it's incorrectly interprettd in the time zone of\n * the device. We correct it here.\n */\nconst _extractDateTimeFromDate = (\n  dateTimeOriginal: Date,\n  locationInfo: LocationInfo,\n  offsetInMinutes: number | null,\n): DateTimeInfo => {\n  // parsed in device tz, so we format it back in same tz\n  const localDateAsString = formatDateYYYYMMDDTHHMMSS(dateTimeOriginal);\n\n  // console.log(\n  //   `${localDateAsString} - ${offsetInMinutes} - ${locationInfo.timeZone}`,\n  // );\n\n  if (offsetInMinutes !== null) {\n    const utcDate = toDateUTC(localDateAsString);\n\n    if (utcDate) {\n      utcDate?.setMinutes(utcDate.getUTCMinutes() - offsetInMinutes);\n    }\n\n    return {\n      localTime: localDateAsString,\n      timestamp: utcDate?.getTime() ?? null,\n    };\n  } else if (locationInfo.timeZone) {\n    const fixedDate = toDateInTimeZone(\n      localDateAsString,\n      locationInfo.timeZone,\n    );\n\n    return {\n      localTime: localDateAsString,\n      timestamp: fixedDate?.getTime() ?? null,\n      // timeZoneOffsetInMinutes: null,\n    };\n  } else {\n    return {\n      localTime: localDateAsString,\n      timestamp: null,\n    };\n  }\n};\n\nexport { extractDateTime };\n"],"names":["convertLatLonToDecimal","coord","match","minutesStr","hemisphere","decimal","parseInt","parseFloat","roundToSignificantDigits","value","n","multiplier","Math","pow","round","parse","pkg","exif","item","_exif","latitude","longitude","timeZone","localTime","timestamp","description","width","height","Promise","resolve","then","data","rawExif","_ref","_rawExif$latitude","_ref2","_rawExif$longitude","locationInfo","GPSLatitude","GPSLongitude","tzlookup","_rawExif$ImageDescrip","imageDescription","ImageDescription","String","trim","extractDescription","dateTimeInfo","_rawExif$DateTimeOrig","_rawExif$OffsetTimeOr","split","hours","dateTimeOriginal","DateTimeOriginal","offsetTimeOriginal","OffsetTimeOriginal","_correctDate$getTime","_correctDate$getTime2","correctDate","toDate","formatDateYYYYMMDDTHHMMSS","getTime","slice","_extractDateTimeFromString","isDate","offsetInMinutes","localDateAsString","_utcDate$getTime","utcDate","toDateUTC","setMinutes","getUTCMinutes","_fixedDate$getTime","fixedDate","toDateInTimeZone","_extractDateTimeFromDate","extractDateTime","_ref3","_rawExif$ImageWidth","_ref4","_rawExif$ImageHeight","_temp4","ImageWidth","ExifImageWidth","ImageHeight","ExifImageHeight","_temp3","_temp2","import","_ref5","probe","fs","createReadStream","results","_temp5","window","file","URL","webkitURL","image","Image","onload","src","createObjectURL","e","reject","getSizeInBrowser","extractHeightWidth","dimensionInfo"],"mappings":"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"}